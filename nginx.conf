worker_processes auto;
worker_cpu_affinity auto;

worker_rlimit_nofile 200000;
pid nginx.pid;

env APP_ENV;
env APP_CLUSTER;
env IDC;

events {
    worker_connections 60000;
    use epoll;
    multi_accept on;
}

http {

    # Basic Settings
    ##
    client_body_buffer_size 64k;
    client_body_in_single_buffer on;

    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    types_hash_max_size 2048;

    include mime.types;
    default_type application/octet-stream;
    server_tokens off;

    http2_idle_timeout 3m;
    http2_recv_timeout 30s;

    port_in_redirect off;

    ##
    # SSL Settings
    ##

    ssl_session_cache           shared:SSL:20m;
    ssl_session_timeout         20m;
    ssl_prefer_server_ciphers   on;
    ssl_protocols               TLSv1.2 TLSv1.3;
    ##
    # Logging Settings
    ##

    include keep.d/logformat.conf;

    access_log logs/access.log json buffer=64k flush=10s;
    error_log  logs/error.log;

    proxy_cache_path static_cache levels=1:2 keys_zone=static:10m max_size=200m;

    ##
    # Gzip Settings
    ##
    gzip on;
    gzip_disable "msie6";

    # gzip_vary on;
    # gzip_proxied any;
    # gzip_comp_level 6;
    # gzip_buffers 16 8k;
    # gzip_http_version 1.1;
    gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;

    limit_req_zone $binary_remote_addr zone=sms:10m rate=2r/m;
    limit_req_zone $binary_remote_addr zone=all:20m rate=100r/s;

    limit_req_zone $binary_remote_addr zone=show:10m rate=2r/s;
    limit_req_zone $http_x_device_id zone=device:10m rate=5r/s;

    # fastcgi_setting
    fastcgi_connect_timeout 300s;
    fastcgi_send_timeout 300s;
    fastcgi_read_timeout 300s;

    include conf.d/*.conf;
    include sites/*.conf;

    include keep.d/proxy.conf;


        ngx.log(ngx.ERR, "start to init worker with id: ", ngx.worker.id() or "null", " APP_ENV: ", env, ", APP_CLUSTER: ", cluster, ", IDC: ", idc)

        local fg = require "lreu.feature_gates"
        fg.enable_feature_inject_x_ngx_cluster_header_to_office_cluster()

        ngx.log(ngx.ERR, "init picker in worker: ", ngx.worker.id() or "null")
        local picker = require "lreu.picker"
        picker.init({
            storage = ngx.shared.lreu_upstream,
            native_idc = idc,
            traffic_switch = {
                route_color_enable = false,
                idc_color_enable = false,
                idc_flow_enable = false,
            },
        })

        ngx.log(ngx.ERR, "init syncer in worker:  ", ngx.worker.id() or "null")
        local syncer = require "lreu.syncer"
        local _, err = syncer.init({
            etcd_host = etcd_clusters[string.lower(env .. "/" .. cluster)],
            etcd_path = "/v1/" .. env .. "/services/",
            storage = ngx.shared.lreu_upstream,
            traffic_control_config_path = "/v1/" .. env .."/traffic_control/",

            -- etcd hc config
            shm_name = "lreu_etcd_hc",
            fail_timeout = 10,
            max_fails = 2,
        })
        if err then
            ngx.log(ngx.ERR, "init syncer in worker:  ", ngx.worker.id() or "null", " err: ", err or "null")
            return
        end
        ngx.log(ngx.ERR, "init syncer in worker:  ", ngx.worker.id() or "null", "success")

        ngx.log(ngx.ERR, "init logger in worker:  ", ngx.worker.id() or "null")
        local logger = require "lreu.logger"
        logger.init(ngx.shared.lreu_logger, 60, ngx.shared.lreu_upstream)

        ngx.log(ngx.ERR, "init health in worker:  ", ngx.worker.id() or "null")
        local health = require "lreu.health"
        health.init({
            storage = ngx.shared.lreu_upstream,
            healthcheck = {
                enable = true,
                timeout = 3,
                interval = 5,
                max_fails = 3,
                ok_status = {200, 204, 301, 302, 401, 403, 404}
            },
            logcheck = {
                enable = false,
                interval = 5,
                recover = 60
            }
        })
    }

    log_by_lua_block {
        local logger = require "lreu.logger"
        logger.calc()
    }
}
