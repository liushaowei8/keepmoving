worker_processes auto;
worker_cpu_affinity auto;

worker_rlimit_nofile 200000;
pid nginx.pid;

env APP_ENV;
env APP_CLUSTER;
env IDC;

events {
    worker_connections 60000;
    use epoll;
    multi_accept on;
}

http {

    # Basic Settings
    ##
    client_body_buffer_size 64k;
    client_body_in_single_buffer on;

    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    types_hash_max_size 2048;

    include mime.types;
    default_type application/octet-stream;
    server_tokens off;

    http2_idle_timeout 3m;
    http2_recv_timeout 30s;

    port_in_redirect off;

    ##
    # SSL Settings
    ##

    ssl_session_cache           shared:SSL:20m;
    ssl_session_timeout         20m;
    ssl_prefer_server_ciphers   on;
    ssl_protocols               TLSv1.2 TLSv1.3;
    ##
    # Logging Settings
    ##

    include keep.d/logformat.conf;

    access_log logs/access.log json buffer=64k flush=10s;
    error_log  logs/error.log;

    proxy_cache_path static_cache levels=1:2 keys_zone=static:10m max_size=200m;

    ##
    # Gzip Settings
    ##
    gzip on;
    gzip_disable "msie6";

    # gzip_vary on;
    # gzip_proxied any;
    # gzip_comp_level 6;
    # gzip_buffers 16 8k;
    # gzip_http_version 1.1;
    gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;

    limit_req_zone $binary_remote_addr zone=sms:10m rate=2r/m;
    limit_req_zone $binary_remote_addr zone=all:20m rate=100r/s;

    limit_req_zone $binary_remote_addr zone=show:10m rate=2r/s;
    limit_req_zone $http_x_device_id zone=device:10m rate=5r/s;

    # fastcgi_setting
    fastcgi_connect_timeout 300s;
    fastcgi_send_timeout 300s;
    fastcgi_read_timeout 300s;

    include conf.d/*.conf;
    include sites/*.conf;

    include keep.d/proxy.conf;

    lua_socket_log_errors off;
    lua_package_path "${prefix}/nginx-office.src/lua/lib/?.lua;;";
    lua_package_cpath "${prefix}/nginx-office.src/lua/clib/?.so;;";
    
    lua_shared_dict lreu_upstream 5m;
    lua_shared_dict lreu_logger 5m;
    lua_shared_dict lreu_etcd_hc 1m;

    lua_max_pending_timers 2048;
    lua_max_running_timers 2048;

    init_worker_by_lua_block {
        local env = os.getenv("APP_ENV")
        local cluster = os.getenv("APP_CLUSTER")
        local idc = os.getenv("IDC")

        ngx.log(ngx.ERR, "start to init worker with id: ", ngx.worker.id() or "null", " APP_ENV: ", env, ", APP_CLUSTER: ", cluster, ", IDC: ", idc)

        local fg = require "lreu.feature_gates"
        fg.enable_feature_inject_x_ngx_cluster_header_to_office_cluster()

        ngx.log(ngx.ERR, "init picker in worker: ", ngx.worker.id() or "null")
        local picker = require "lreu.picker"
        picker.init({
            storage = ngx.shared.lreu_upstream,
            native_idc = idc,
            traffic_switch = {
                route_color_enable = false,
                idc_color_enable = false,
                idc_flow_enable = false,
            },
        })

        local etcd_clusters = {
            ["dev/dev"] = {"http://172.16.1.28:2379", "http://172.16.1.28:2379", "http://172.16.1.28:2379"},
            ["pre/bjtx"] = {"http://172.19.3.126:2379", "http://172.19.3.142:2379","http://172.19.8.93:2379"},
            ["online/bjtx"] = {"http://172.30.17.98:2379","http://172.30.2.15:2379","http://172.30.8.3:2379"},
            ["online/bjali"] = {"http://10.202.58.169:2379","http://10.202.58.170:2379","http://10.202.79.89:2379","http://10.202.79.90:2379","http://10.202.83.30:2379"},
        }

        ngx.log(ngx.ERR, "init syncer in worker:  ", ngx.worker.id() or "null")
        local syncer = require "lreu.syncer"
        local _, err = syncer.init({
            etcd_host = etcd_clusters[string.lower(env .. "/" .. cluster)],
            etcd_path = "/v1/" .. env .. "/services/",
            storage = ngx.shared.lreu_upstream,
            traffic_control_config_path = "/v1/" .. env .."/traffic_control/",

            -- etcd hc config
            shm_name = "lreu_etcd_hc",
            fail_timeout = 10,
            max_fails = 2,
        })
        if err then
            ngx.log(ngx.ERR, "init syncer in worker:  ", ngx.worker.id() or "null", " err: ", err or "null")
            return
        end
        ngx.log(ngx.ERR, "init syncer in worker:  ", ngx.worker.id() or "null", "success")

        ngx.log(ngx.ERR, "init logger in worker:  ", ngx.worker.id() or "null")
        local logger = require "lreu.logger"
        logger.init(ngx.shared.lreu_logger, 60, ngx.shared.lreu_upstream)

        ngx.log(ngx.ERR, "init health in worker:  ", ngx.worker.id() or "null")
        local health = require "lreu.health"
        health.init({
            storage = ngx.shared.lreu_upstream,
            healthcheck = {
                enable = true,
                timeout = 3,
                interval = 5,
                max_fails = 3,
                ok_status = {200, 204, 301, 302, 401, 403, 404}
            },
            logcheck = {
                enable = false,
                interval = 5,
                recover = 60
            }
        })
    }

    log_by_lua_block {
        local logger = require "lreu.logger"
        logger.calc()
    }
}
